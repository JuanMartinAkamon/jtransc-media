---------------------------------------------------------------------------------

mappings.map("jtransc.JTranscEventLoop") {
    body(VOID, "init", ARGS(RUNNABLE), """
        return HaxeNatives.loopInit(p0.run__V);
    """)

    body(VOID, "loop", ARGS(RUNNABLE, RUNNABLE), """
        return HaxeNatives.loopLoop(p0.run__V, p1.run__V);
    """)
}

mappings.map("jtransc.JTranscIO") {
    val CALLBACK = AstType.REF("jtransc.JTranscCallback")
    body(VOID, "readAsync", ARGS(STRING, CALLBACK), """
        HaxeNatives.readAsync(p0._str, p1.handler_Ljava_lang_Throwable_Ljava_lang_Object__V);
    """)
}

---------------------------------------------------------------------------------

static public var initHandler: Void -> Void;
static public var updateHandler: Void -> Void;
static public var renderHandler: Void -> Void;
static public var enabledDefaultEventLoop: Bool = true;

static public function loopInit(init: Void -> Void) {
    HaxeNatives.initHandler = init;
}

static public function loopLoop(update: Void -> Void, render: Void -> Void) {
    HaxeNatives.updateHandler = update;
    HaxeNatives.renderHandler = render;
    if (enabledDefaultEventLoop) defaultEventLoop();
}

static public function defaultEventLoop() {
    initHandler();

    #if js
    function _step(ms) {
        updateHandler();
        renderHandler();
        js.Browser.window.requestAnimationFrame(_step);
    }
    _step(0.0);
    #elseif flash
        flash.Lib.current.stage.addEventListener(flash.events.Event.ENTER_FRAME, function(e) {
            updateHandler();
            renderHandler();
        });
    #elseif sys
    while (true) {
        updateHandler();
        renderHandler();
        Sys.sleep(1000.0 / 60.0);
    }
    #else
    throw 'Not supported JTranscEventLoop.loop';
    #end
}

---------------------------------------------------------------------------------
